/*
 * Copyright (c) 1996-2001
 * Logica Mobile Networks Limited
 * All rights reserved.
 *
 * This software is distributed under Logica Open Source License Version 1.0
 * ("Licence Agreement"). You shall use it and distribute only in accordance
 * with the terms of the License Agreement.
 *
 */
package vn.vnpay.sms.receiver;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.smpp.*;
import org.smpp.pdu.PDU;
import org.smpp.pdu.Request;
import org.smpp.pdu.Response;
import org.smpp.pdu.ValueNotSetException;
import vn.vnpay.db.DatabaseWorker;

import java.io.IOException;
import java.sql.SQLException;

import static org.smpp.util.Utils.MD5Hash;

/**
 * This class represent one client connection to the server starting
 * by accepting the connection, authenticating of the client,
 * communication and finished by unbinding.
 * The <code>SMSCSession</code> object is generated by <code>SMSCListener</code>
 * which also sets the session's PDU processor. Session is run in separate
 * thread; it reads PDUs from the connection and calls PDU processor's
 * client methods to process the received PDUs. PDU processor on turn can
 * use the session to submit PDUs to the client.
 * For receiving and sending of PDUs the session uses instances of
 * <code>SMSCServer</code> and <code>Transmitter</code>.
 *
 * @see SMSCListener
 * @see PDUProcessor
 * @see Connection
 * @see SMSCServer
 * @see Transmitter
 */
public class SMSCSession extends SmppObject
        implements Runnable {
    private static Log logger = LogFactory.getLog(SMSCSession.class);
    private static String txt_receiver = "SMSCServer: ";
    private Receiver receiver;
    private Transmitter transmitter;
    private PDUProcessor pduProcessor;
    private Connection connection;
    private long receiveTimeout = Data.RECEIVER_TIMEOUT;
    private boolean keepReceiving = true;
    private boolean isReceiving = false;
    private String sessionId;
    private String ipAddress;
    private String username;
    private java.sql.Connection dbConn = null;
    private DatabaseWorker dbworker = null;
    private String queueName = "";

    /**
     * Initialises the session with the connection the session
     * should communicate over.
     *
     * @param connection the connection object for communication with client
     */
    public SMSCSession(Connection connection) {
        this.connection = connection;
        ipAddress = connection.getAddress();
        transmitter = new Transmitter(connection);
        receiver = new Receiver(transmitter, connection);
        sessionId = MD5Hash(String.valueOf(ipAddress + System.currentTimeMillis()));
        receiver.setSessionId(sessionId);

    }

    /**
     * Signals the session's thread that it should stop.
     * Doesn't wait for the thread to be completly finished.
     * Note that it can take some time before the thread is completly
     * stopped.
     *
     * @see #run()
     */
    public void stop() {
        logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession stopping");
        keepReceiving = false;
        dbworker.set_user_logout(sessionId);
        try {
            dbConn.close();
        } catch (SQLException e) {
            logger.error(txt_receiver + e.toString(), e);
        }
    }

    /**
     * Implements the logic of receiving of the PDUs from client and passing
     * them to PDU processor. First starts SMSCServer, then in cycle
     * receives PDUs and passes them to the proper PDU processor's
     * methods. After the function <code>stop</code> is called (externally)
     * stops the SMSCServer, exits the PDU processor and closes the connection,
     * so no extry tidy-up routines are necessary.
     *
     * @see #stop()
     * @see PDUProcessor#clientResponse(Response)
     */
    public void run() {
        PDU pdu = null;
        logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] starting receive with sessionId: " + sessionId);
        receiver.start();
        dbworker = new DatabaseWorker(dbConn);
        dbworker.setQueueName(queueName);
        isReceiving = true;
        try {
            while (keepReceiving) {
                if (keepReceiving == false) break;
                try {
                    //logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession going to receive PDU ...................................................");
                    pdu = receiver.receive(getReceiveTimeout());
                } catch (Exception e) {
                    logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession caught exception receiving PDU " + e.getMessage());
                }

                if (pdu != null) {
                    if (pdu.isRequest()) {
                        logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] Client Request: " + pdu.debugString());
                        pduProcessor.clientRequest((Request) pdu);
                    } else if (pdu.isResponse()) {
                        logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] Client Response: " + pdu.debugString());
                        pduProcessor.clientResponse((Response) pdu);
                    } else {
                        logger.info(txt_receiver + "SMSCSession not request nor response => not doing anything.");
                    }
                } else {
                    logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] client timeout (close thread: " + Thread.currentThread().getName() + ")");
                    keepReceiving = false;
                }
            }
            logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] stop receive with session:" + sessionId);
            receiver.stop();
            logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] exiting PDUProcessor");

        } finally {
            isReceiving = false;
        }
        try {
            logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession closing");
            connection.close();
        } catch (IOException e) {
            logger.error("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession close caught IOException:" + e.getMessage());
        }
        pduProcessor.exit();
    }

    /**
     * Sends PropertiesConfig PDU to the client.
     *
     * @param pdu the PDU to send
     */
    public void send(PDU pdu) {
        try {
            transmitter.send(pdu);
            //logger.info("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession sent pdu over transmitter");
        } catch (ValueNotSetException e) {
            event.write(e, "");
            logger.error("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession caught ValueNotSetException sent pdu over transmitter: " + e.getMessage());
        } catch (IOException e) {
            logger.error("[" + pduProcessor.getSystemId() + "/" + ipAddress + "] SMSCSession caught IOException sent pdu over transmitter: " + e.getMessage());
        }
    }

    /**
     * Sets new PDU processor.
     *
     * @param pduProcessor the new PDU processor
     */
    public void setPDUProcessor(PDUProcessor pduProcessor) {
        this.pduProcessor = pduProcessor;
    }

    /**
     * Sets the timeout for receiving the complete message.
     *
     * @param timeout the new timeout value
     */
    public void setReceiveTimeout(long timeout) {
        receiveTimeout = timeout;
    }

    /**
     * Returns the current setting of receiving timeout.
     *
     * @return the current timeout value
     */
    public long getReceiveTimeout() {
        return receiveTimeout;
    }

    public String getSessionId() {
        return sessionId;
    }

    public String getIpAddress() {
        return ipAddress;
    }


    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setDbConn(java.sql.Connection dbConn) {
        this.dbConn = dbConn;
    }

    public DatabaseWorker getDbworker() {
        return this.dbworker;
    }

    public void setQueueName(String queueName) {
        this.queueName = queueName;
    }
}
